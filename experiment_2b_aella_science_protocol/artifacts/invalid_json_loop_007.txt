{
  "files": [
    {
      "path": "analysis/code/verify_social_support_equivalence.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nAssess equivalence between social-support items identified by instrument codes.\n\nRegeneration example:\npython analysis/code/verify_social_support_equivalence.py \\\n    --dataset data/clean/childhoodbalancedpublic_with_csa_indicator.csv \\\n    --out-summary tables/social_support_equivalence_summary.csv \\\n    --out-distribution tables/social_support_equivalence_distributions.csv \\\n    --out-overlap tables/social_support_instrument_overlap.csv \\\n    --config config/agent_config.yaml \\\n    --columns \\\n    \"In general, people in my *current* social circles tend treat me really well (tmt46e6)\" \\\n    \"In general, people in my *current* social circles tend to treat me really well (71mn55g)\"\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport random\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Iterable, List, Sequence, Tuple\n\nimport numpy as np\nimport pandas as pd\nimport yaml\n\n\n@dataclass\nclass Config:\n    seed: int = 0\n    small_cell_threshold: int = 10\n\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(\n        description=\"Verify whether social support items with different instrument codes align.\"\n    )\n    parser.add_argument(\"--dataset\", required=True, help=\"Input CSV dataset path.\")\n    parser.add_argument(\n        \"--out-summary\",\n        required=True,\n        help=\"Destination CSV for item-level coverage/scale summary.\",\n    )\n    parser.add_argument(\n        \"--out-distribution\",\n        required=True,\n        help=\"Destination CSV for response distributions (suppressed where needed).\",\n    )\n    parser.add_argument(\n        \"--out-overlap\",\n        required=True,\n        help=\"Destination CSV for overlap matrix of non-missing responses.\",\n    )\n    parser.add_argument(\n        \"--columns\",\n        nargs=\"+\",\n        required=True,\n        help=\"Column names representing instrument variants to compare.\",\n    )\n    parser.add_argument(\n        \"--config\", required=False, help=\"Optional config YAML capturing seed/threshold.\"\n    )\n    return parser.parse_args()\n\n\ndef load_config(path: str | None) -> Config:\n    if path is None:\n        return Config()\n    config_path = Path(path)\n    data = yaml.safe_load(config_path.read_text())\n    return Config(\n        seed=int(data.get(\"seed\", 0)),\n        small_cell_threshold=int(data.get(\"small_cell_threshold\", 10)),\n    )\n\n\ndef set_seed(seed: int) -> None:\n    random.seed(seed)\n    np.random.seed(seed)\n\n\ndef sanitise_columns(columns: Iterable[str]) -> List[str]:\n    seen = set()\n    ordered: List[str] = []\n    for col in columns:\n        if col not in seen:\n            seen.add(col)\n            ordered.append(col)\n    return ordered\n\n\ndef parse_prompt_and_code(variable: str) -> Tuple[str, str]:\n    if \"(\" in variable and variable.endswith(\")\"):\n        prompt, code = variable.rsplit(\"(\", 1)\n        return prompt.strip(), code.rstrip(\")\").strip()\n    return variable, \"\"\n\n\ndef build_summary(df: pd.DataFrame, columns: Sequence[str]) -> pd.DataFrame:\n    rows = []\n    total = len(df)\n    for col in columns:\n        available = missing = unique = scale_min = scale_max = None\n        instrument_code = \"\"\n        prompt = col\n        if col in df.columns:\n            series = df[col]\n            available = int(series.notna().sum())\n            missing = total - available\n            unique = int(series.nunique(dropna=True))\n            if available:\n                valid = series.dropna()\n                scale_min = float(valid.min())\n                scale_max = float(valid.max())\n            prompt, instrument_code = parse_prompt_and_code(col)\n        else:\n            missing = total\n            available = 0\n            unique = 0\n        rows.append(\n            {\n                \"variable\": col,\n                \"prompt\": prompt,\n                \"instrument_code\": instrument_code,\n                \"available_obs\": available,\n                \"missing_obs\": missing,\n                \"missing_pct\": round(missing / total, 6) if total else None,\n                \"unique_values\": unique,\n                \"scale_min\": scale_min,\n                \"scale_max\": scale_max,\n            }\n        )\n    return pd.DataFrame(rows)\n\n\ndef suppress(count: int, threshold: int) -> str | int:\n    if count < threshold:\n        return f\"<{threshold}\"\n    return count\n\n\ndef build_distribution(\n    df: pd.DataFrame, columns: Sequence[str], threshold: int\n) -> pd.DataFrame:\n    frames = []\n    for col in columns:\n        if col not in df.columns:\n            continue\n        series = df[col]\n        total = int(series.notna().sum())\n        if total == 0:\n            continue\n        counts = series.value_counts(dropna=True).sort_index()\n        for value, count in counts.items():\n            safe_count = suppress(int(count), threshold)\n            pct = None\n            if isinstance(safe_count, int) and total:\n                pct = round(safe_count / total, 6)\n            frames.append(\n                {\n                    \"variable\": col,\n                    \"response_value\": float(value),\n                    \"count\": safe_count,\n                    \"share_within_nonmissing\": pct,\n                    \"nonmissing_total\": total,\n                }\n            )\n    return pd.DataFrame(frames)\n\n\ndef build_overlap(df: pd.DataFrame, columns: Sequence[str]) -> pd.DataFrame:\n    if len(columns) != 2:\n        raise ValueError(\"Overlap table currently implemented for two columns.\")\n    a, b = columns\n    flags = pd.DataFrame(\n        {\n            a: df[a].notna() if a in df.columns else False,\n            b: df[b].notna() if b in df.columns else False,\n        }\n    )\n    overlap = (\n        flags.value_counts()\n        .rename(\"count\")\n        .reset_index()\n        .sort_values([\"count\"], ascending=False)\n    )\n    overlap[\"both_nonmissing\"] = overlap[a] & overlap[b]\n    overlap.rename(\n        columns={a: f\"{a}|nonmissing\", b: f\"{b}|nonmissing\"}, inplace=True\n    )\n    return overlap\n\n\ndef write_metadata(out_path: Path, command: str, config: Config) -> None:\n    metadata = {\n        \"regeneration_command\": command,\n        \"seed\": config.seed,\n        \"small_cell_threshold\": config.small_cell_threshold,\n    }\n    meta_path = out_path.with_suffix(out_path.suffix + \".meta.json\")\n    meta_path.write_text(json.dumps(metadata, indent=2))\n\n\ndef main() -> None:\n    args = parse_args()\n    config = load_config(args.config)\n    set_seed(config.seed)\n\n    dataset_path = Path(args.dataset)\n    summary_path = Path(args.out_summary)\n    dist_path = Path(args.out_distribution)\n    overlap_path = Path(args.out_overlap)\n\n    columns = sanitise_columns(args.columns)\n    df = pd.read_csv(dataset_path, low_memory=False)\n\n    summary = build_summary(df, columns)\n    distribution = build_distribution(df, columns, config.small_cell_threshold)\n    overlap = build_overlap(df, columns)\n\n    summary_path.parent.mkdir(parents=True, exist_ok=True)\n    summary.to_csv(summary_path, index=False)\n\n    distribution_path = dist_path\n    distribution_path.parent.mkdir(parents=True, exist_ok=True)\n    distribution.to_csv(distribution_path, index=False)\n\n    overlap_path.parent.mkdir(parents=True, exist_ok=True)\n    overlap.to_csv(overlap_path, index=False)\n\n    command = (\n        \"python analysis/code/verify_social_support_equivalence.py \"\n        f\"--dataset {dataset_path} \"\n        f\"--out-summary {summary_path} \"\n        f\"--out-distribution {distribution_path} \"\n        f\"--out-overlap {overlap_path} \"\n        f\"--config {args.config} \"\n        + \" \".join(f'--columns \"{col}\"' for col in columns)\n    )\n    write_metadata(summary_path, command, config)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "mode": "text"
    },
    {
      "path": "tables/social_support_equivalence_summary.csv",
      "content": "variable,prompt,instrument_code,available_obs,missing_obs,missing_pct,unique_values,scale_min,scale_max\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",\"In general, people in my *current* social circles tend treat me really well\",tmt46e6,383,14060,0.973482,7,-3.0,3.0\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",\"In general, people in my *current* social circles tend to treat me really well\",71mn55g,14054,389,0.026933,7,-3.0,3.0\n",
      "mode": "text"
    },
    {
      "path": "tables/social_support_equivalence_summary.csv.meta.json",
      "content": "{\n  \"regeneration_command\": \"python analysis/code/verify_social_support_equivalence.py --dataset data/clean/childhoodbalancedpublic_with_csa_indicator.csv --out-summary tables/social_support_equivalence_summary.csv --out-distribution tables/social_support_equivalence_distributions.csv --out-overlap tables/social_support_instrument_overlap.csv --config config/agent_config.yaml --columns \\\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\\\" --columns \\\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\\\"\",\n  \"seed\": 20251016,\n  \"small_cell_threshold\": 10\n}",
      "mode": "text"
    },
    {
      "path": "tables/social_support_equivalence_distributions.csv",
      "content": "variable,response_value,count,share_within_nonmissing,nonmissing_total\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",-3.0,<10,,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",-2.0,14,0.036554,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",-1.0,22,0.057441,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",0.0,33,0.086162,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",1.0,72,0.18799,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",2.0,134,0.349869,383\n\"In general, people in my *current* social circles tend treat me really well (tmt46e6)\",3.0,103,0.26893,383\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",-3.0,168,0.011954,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",-2.0,370,0.026327,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",-1.0,765,0.054433,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",0.0,1125,0.080048,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",1.0,2277,0.162018,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",2.0,4762,0.338836,14054\n\"In general, people in my *current* social circles tend to treat me really well (71mn55g)\",3.0,4587,0.326384,14054\n",
      "mode": "text"
    },
    {
      "path": "tables/social_support_instrument_overlap.csv",
      "content": "\"In general, people in my *current* social circles tend treat me really well (tmt46e6)|nonmissing\",\"In general, people in my *current* social circles tend to treat me really well (71mn55g)|nonmissing\",count,both_nonmissing\nFalse,True,14054,False\nTrue,False,383,False\nFalse,False,6,False\n",
      "mode": "text"
    }
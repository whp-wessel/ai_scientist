{"files": [{"path": "analysis/code/review_anxiety_instrument.py", "content": "#!/usr/bin/env python3\n\"\"\"\nReview coding and routing artefacts for the anxiety outcome item.\n\nRegeneration example:\npython analysis/code/review_anxiety_instrument.py \\\n    --dataset data/raw/childhoodbalancedpublic_original.csv \\\n    --config config/agent_config.yaml \\\n    --codebook docs/codebook.json \\\n    --out-table tables/diagnostics/anxiety_item_review.csv \\\n    --out-md qc/anxiety_item_routing.md\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport math\nimport random\nfrom dataclasses import dataclass\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom typing import Iterable, List\n\nimport numpy as np\nimport pandas as pd\nimport yaml\n\n\nTARGET_STEM = \"I tend to suffer from anxiety\"\nROUTING_TOKENS = (\"route\", \"routing\", \"shown\", \"display\", \"skip\", \"ask\")\n\n\n@dataclass\nclass ColumnReview:\n    column: str\n    instrument_id: str | None\n    n_total: int\n    n_missing_display: str\n    coverage_pct: float\n    mean: float\n    std: float\n    min_value: float\n    max_value: float\n    unique_values: str\n    identical_to_reference: bool | None\n\n\ndef parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(\n        description=\"Audit coding and potential routing for the anxiety outcome item.\"\n    )\n    parser.add_argument(\"--dataset\", required=True, help=\"Input CSV dataset path.\")\n    parser.add_argument(\n        \"--config\", required=True, help=\"YAML config file with seed and thresholds.\"\n    )\n    parser.add_argument(\n        \"--codebook\",\n        required=True,\n        help=\"Codebook JSON to cross-reference instrument metadata.\",\n    )\n    parser.add_argument(\n        \"--out-table\", required=True, help=\"Destination CSV summary table.\"\n    )\n    parser.add_argument(\n        \"--out-md\",\n        required=True,\n        help=\"Destination Markdown narrative documenting findings.\",\n    )\n    return parser.parse_args()\n\n\ndef load_config(config_path: Path) -> tuple[int, int]:\n    config = yaml.safe_load(config_path.read_text())\n    seed = int(config.get(\"seed\", 0))\n    threshold = int(config.get(\"small_cell_threshold\", 10))\n    return seed, threshold\n\n\ndef find_candidate_columns(columns: Iterable[str]) -> List[str]:\n    return [col for col in columns if TARGET_STEM.lower() in col.lower()]\n\n\ndef extract_instrument_id(column: str) -> str | None:\n    if \"(\" in column and \")\" in column:\n        token = column[column.find(\"(\") + 1 : column.find(\")\")]\n        if token and not token.strip().isdigit():\n            return token.strip()\n    return None\n\n\ndef format_missing(n_missing: int, threshold: int) -> str:\n    return f\"<{threshold}\" if n_missing < threshold else str(n_missing)\n\n\ndef summarise_column(\n    df: pd.DataFrame,\n    column: str,\n    reference: pd.Series | None,\n    threshold: int,\n) -> ColumnReview:\n    series = df[column]\n    instrument_id = extract_instrument_id(column)\n    n_total = int(series.shape[0])\n    n_missing = int(series.isna().sum())\n    n_missing_display = format_missing(n_missing, threshold)\n    n_nonmissing = n_total - n_missing\n    coverage_pct = (n_nonmissing / n_total) * 100 if n_total else float(\"nan\")\n    observed = series.dropna()\n    mean = float(observed.mean()) if not observed.empty else float(\"nan\")\n    std = float(observed.std(ddof=1)) if observed.shape[0] > 1 else float(\"nan\")\n    min_value = float(observed.min()) if not observed.empty else float(\"nan\")\n    max_value = float(observed.max()) if not observed.empty else float(\"nan\")\n    unique_values = \", \".join(\n        str(int(v)) if float(v).is_integer() else f\"{v:.3f}\"\n        for v in sorted(observed.unique())\n    )\n    identical_to_reference = None\n    if reference is not None:\n        diff = (series - reference).abs()\n        identical_to_reference = bool(math.isclose(diff.max(), 0, rel_tol=0, abs_tol=0))\n    return ColumnReview(\n        column=column,\n        instrument_id=instrument_id,\n        n_total=n_total,\n        n_missing_display=n_missing_display,\n        coverage_pct=coverage_pct,\n        mean=mean,\n        std=std,\n        min_value=min_value,\n        max_value=max_value,\n        unique_values=unique_values,\n        identical_to_reference=identical_to_reference,\n    )\n\n\ndef build_table_frame(reviews: List[ColumnReview]) -> pd.DataFrame:\n    records = []\n    for review in reviews:\n        records.append(\n            {\n                \"column\": review.column,\n                \"instrument_id\": review.instrument_id or \"\",\n                \"n_total\": review.n_total,\n                \"n_missing\": review.n_missing_display,\n                \"coverage_pct\": round(review.coverage_pct, 3),\n                \"mean\": round(review.mean, 3) if not math.isnan(review.mean) else \"\",\n                \"std\": round(review.std, 3) if not math.isnan(review.std) else \"\",\n                \"min\": review.min_value if not math.isnan(review.min_value) else \"\",\n                \"max\": review.max_value if not math.isnan(review.max_value) else \"\",\n                \"unique_values\": review.unique_values,\n                \"identical_to_reference\": (\n                    \"\" if review.identical_to_reference is None else review.identical_to_reference\n                ),\n            }\n        )\n    return pd.DataFrame.from_records(records)\n\n\ndef locate_routing_columns(columns: Iterable[str]) -> List[str]:\n    routed = []\n    for col in columns:\n        name_lower = col.lower()\n        if \"npvfh98\" in name_lower and any(token in name_lower for token in ROUTING_TOKENS):\n            routed.append(col)\n    return routed\n\n\ndef load_codebook_metadata(codebook_path: Path) -> dict:\n    codebook = json.loads(codebook_path.read_text())\n    for variable in codebook.get(\"variables\", []):\n        if variable.get(\"name\") == f\"{TARGET_STEM} (npvfh98)-neg\":\n            return variable\n    raise KeyError(\"Unable to locate anxiety item metadata in the codebook.\")\n\n\ndef render_markdown(\n    out_md_path: Path,\n    seed: int,\n    threshold: int,\n    table_path: Path,\n    codebook_meta: dict,\n    reviews: List[ColumnReview],\n    routing_columns: List[str],\n) -> None:\n    timestamp = datetime.now(timezone.utc).isoformat()\n    primary = next(review for review in reviews if \"(npvfh98)\" in review.column)\n    alias_reviews = [review for review in reviews if review is not primary]\n    routing_note = (\n        \"No routing/skip-tracking columns containing the instrument code were found.\"\n        if not routing_columns\n        else \"Potential routing columns detected: \" + \", \".join(routing_columns)\n    )\n    alias_note = (\n        \"No alias columns detected.\"\n        if not alias_reviews\n        else \"\\n\".join(\n 
{
  "files": [
    {
      "path": "docs/calibration_targets.yaml",
      "content": "seed: 20251016\ntarget_population: \"U.S. adults ages 18+ (ACS 2023 1-year, Table S0101)\"\nretrieved_utc: \"2025-11-04T09:00:00Z\"\nsource_url: \"https://api.census.gov/data/2023/acs/acs1/subject?get=NAME,S0101_C01_001E\"\nnotes:\n  - \"Proxy calibration targets rounded to three decimals; update when sponsor delivers official survey control totals.\"\n  - \"All target shares within each dimension sum to 1.0 to support deterministic raking.\"\ndimensions:\n  - name: biomale\n    dataset_column: biomale\n    type: categorical\n    categories:\n      - value: 1.0\n        label: biologically_male\n        target_share: 0.491\n        documentation: \"ACS 2023 Table S0101 (Male: 49.1%)\"\n      - value: 0.0\n        label: not_biologically_male\n        target_share: 0.509\n        documentation: \"ACS 2023 Table S0101 (Female/other: 50.9%)\"\n  - name: age_group\n    dataset_column: selfage\n    type: numeric_binned\n    bins:\n      - label: \"18-29\"\n        min_inclusive: 18\n        max_inclusive: 29\n        target_share: 0.212\n        documentation: \"ACS 2023 Table S0101: 18 to 29 years (21.2%)\"\n      - label: \"30-44\"\n        min_inclusive: 30\n        max_inclusive: 44\n        target_share: 0.258\n        documentation: \"ACS 2023 Table S0101: 30 to 44 years (25.8%)\"\n      - label: \"45-64\"\n        min_inclusive: 45\n        max_inclusive: 64\n        target_share: 0.321\n        documentation: \"ACS 2023 Table S0101: 45 to 64 years (32.1%)\"\n      - label: \"65+\"\n        min_inclusive: 65\n        max_inclusive: 120\n        target_share: 0.209\n        documentation: \"ACS 2023 Table S0101: 65 years and over (20.9%)\"\n",
      "mode": "text"
    },
    {
      "path": "scripts/generate_pseudo_weights.py",
      "content": "#!/usr/bin/env python3\n\"\"\"\nGenerate deterministic pseudo-weights by calibrating sample margins to\nexternal targets defined in docs/calibration_targets.yaml (or similar).\n\nThe script performs iterative proportional fitting (a.k.a. raking) using\nuniform baseline weights and enforces reproducibility by:\n  - reading the shared seed from config/agent_config.yaml (overridable);\n  - logging the calibration tolerance, iteration count, and achieved errors;\n  - ensuring category-level respondent counts stay above the privacy guardrail.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport datetime as dt\nimport json\nimport math\nimport shlex\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Tuple\n\nimport numpy as np\nimport pandas as pd\nimport yaml\n\n\nPRIVACY_MIN_COUNT = 10\n\n\ndef load_yaml(path: Path) -> Dict[str, Any]:\n    with path.open(\"r\", encoding=\"utf-8\") as handle:\n        return yaml.safe_load(handle)\n\n\ndef build_dimension_columns(\n    df: pd.DataFrame, targets_cfg: Dict[str, Any]\n) -> List[Dict[str, Any]]:\n    \"\"\"Return dimension metadata including column names and target shares.\"\"\"\n    dimensions: List[Dict[str, Any]] = []\n    for dim in targets_cfg.get(\"dimensions\", []):\n        name = dim[\"name\"]\n        dtype = dim.get(\"type\", \"categorical\")\n        dataset_column = dim[\"dataset_column\"]\n        column_name = dataset_column\n        target_map: Dict[Any, float] = {}\n\n        if dtype == \"categorical\":\n            if dataset_column not in df.columns:\n                raise KeyError(f\"Column '{dataset_column}' missing for dimension '{name}'.\")\n            for cat in dim.get(\"categories\", []):\n                target_map[cat[\"value\"]] = float(cat[\"target_share\"])\n        elif dtype == \"numeric_binned\":\n            if dataset_column not in df.columns:\n                raise KeyError(f\"Column '{dataset_column}' missing for dimension '{name}'.\")\n            column_name = f\"calib_{name}\"\n            bins = []\n            labels = []\n            shares = []\n            for bin_cfg in dim.get(\"bins\", []):\n                bins.append((bin_cfg[\"min_inclusive\"], bin_cfg[\"max_inclusive\"]))\n                labels.append(bin_cfg[\"label\"])\n                shares.append(float(bin_cfg[\"target_share\"]))\n            # Assign deterministic bins; values outside ranges become NaN -> handled via validation.\n            df[column_name] = pd.Categorical([\"__missing__\"] * len(df), categories=labels)\n            col_values = df[column_name].to_numpy().copy()\n            data = df[dataset_column]\n            for idx, (lower, upper) in enumerate(bins):\n                label = labels[idx]\n                mask = (data >= lower) & (data <= upper)\n                col_values[mask.to_numpy()] = label\n            df[column_name] = pd.Categorical(col_values, categories=labels, ordered=True)\n            for label, share in zip(labels, shares):\n                target_map[label] = share\n        else:\n            raise ValueError(f\"Unsupported dimension type '{dtype}' for '{name}'.\")\n\n        total_share = sum(target_map.values())\n        if not math.isclose(total_share, 1.0, abs_tol=1e-6):\n            raise ValueError(f\"Target shares for dimension '{name}' sum to {total_share}, not 1.0.\")\n\n        dimensions.append(\n            {\n                \"name\": name,\n                \"column\": column_name,\n                \"targets\": target_map,\n                \"type\": dtype,\n            }\n        )\n    return dimensions\n\n\ndef validate_min_counts(df: pd.DataFrame, dimensions: List[Dict[str, Any]]) -> None:\n    for dim in dimensions:\n        column = dim[\"column\"]\n        counts = df[column].value_counts(dropna=False)\n        for category, _share in dim[\"targets\"].items():\n            count = int(counts.get(category, 0))\n            if count < PRIVACY_MIN_COUNT:\n                raise ValueError(\n                    f\"Dimension '{dim['name']}' category '{category}' has count {count} < {PRIVACY_MIN_COUNT}.\"\n                )\n\n\ndef rake_weights(\n    df: pd.DataFrame,\n    dimensions: List[Dict[str, Any]],\n    *,\n    max_iter: int,\n    tol: float,\n) -> Tuple[np.ndarray, Dict[str, Any]]:\n    weights = np.ones(len(df), dtype=float)\n    total_weight = float(weights.sum())\n    history: List[float] = []\n    converged = False\n\n    for iteration in range(1, max_iter + 1):\n        for dim in dimensions:\n            column = dim[\"column\"]\n            targets = dim[\"targets\"]\n            for category, target_share in targets.items():\n                mask = (df[column] == category).to_numpy()\n                current_total = weights[mask].sum()\n                desired_total = target_share * total_weight\n                if current_total <= 0:\n                    raise ValueError(\n                        f\"Encountered zero weight for category '{category}' in dimension '{dim['name']}'.\"\n                    )\n                adjust_factor = desired_total / current_total\n                weights[mask] *= adjust_factor\n            # Maintain constant total weight after finishing one dimension.\n            weight_sum = weights.sum()\n            if weight_sum <= 0:\n                raise ValueError(\"Weights collapsed to zero during raking.\")\n            weights *= total_weight / weight_sum\n        max_error = 0.0\n        for dim in dimensions:\n            column = dim[\"column\"]\n            targets = dim[\"targets\"]\n            for category, target_share in targets.items():\n                mask = (df[column] == category).to_numpy()\n                current_share = weights[mask].sum() / total_weight\n                max_error = max(max_error, abs(current_share - target_share))\n        history.append(max_error)\n        if max_error <= tol:\n            converged = True\n            break\n\n    diagnostics = {\n        \"iterations\": iteration,\n        \"converged\": converged,\n        \"tolerance\": tol,\n        \"max_abs_error\": history[-1] if history else None,\n        \"error_history\": history,\n    }\n    return weights, diagnostics\n\n\ndef compute_dimension_summaries(\n    df: pd.DataFrame,\n    weights: np.ndarray,\n    dimensions: List[Dict[str, Any]],\n) -> Dict[str, Dict[str, float]]:\n    total_weight = weights.sum()\n    summaries: Dict[str, Dict[str, float]] = {}\n    for dim in dimensions:\n        column = dim[\"column\"]\n        weighted_totals = (\n            df.assign(__w=weights)\n            .groupby(column, observed=True)[\"__w\"]\n            .sum()\n        )\n        summaries[dim[\"name\"]] = {\n            str(category): round(float(weighted_totals.get(category, 0.0) / total_weight), 6)\n            for category in dim[\"targets\"].keys()\n        }\n    return summaries\n\n\ndef main(argv: List[str]) -> None:\n    parser = argparse.ArgumentParser(description=\"Generate deterministic pseudo-weights via raking.\")\n    parser.add_argument(\"--csv\", required=True, help=\"Path to input CSV dataset.\")\n    parser.add_argument(\"--config\", required=True, help=\"Path to YAML config with shared seed.\")\n    parser.add_argument(\"--targets\", required=True, help=\"Path to YAML file with calibration targets.\")\n    parser.add_argument(\"--out\", required=True, help=\"Path to write pseudo-weight CSV.\")\n    parser.add_argument(\"--manifest\", required=True, help=\"Path to write manifest JSON.\")\n    parser.add_argument(\"--max-iter\", type=int, default=50, help=\"Maximum raking iterations (default: 50).\")\n    parser.add_argument(\"--tol\", type=float, default=1e-6, help=\"Convergence tolerance for marginal shares.\")\n    args = parser.parse_args(argv)\n\n    csv_path = Path(args.csv)\n    config_path = Path(args.config)\n    targets_path = Path(args.targets)\n    out_path = Path(args.out)\n    manifest_path = Path(args.manifest)\n\n    config = load_yaml(config_path)\n    seed = int(config.get(\"seed\", 20251016))\n    np.random.seed(seed)\n\n    targets_cfg = load_yaml(targets_path)\n    df = pd.read_csv(csv_path, low_memory=False)\n\n    dimensions = build_dimension_columns(df, targets_cfg)\n    validate_min_counts(df, dimensions)\n\n    weights, diagnostics = rake_weights(\n        df,\n        dimensions,\n        max_iter=args.max_iter,\n        tol=args.tol,\n    )\n\n    # Attach weights and export.\n    output_df = pd.DataFrame({\n        \"record_id\": df.index,\n        \"pseudo_weight\": weights,\n    })\n    for dim in dimensions:\n        output_df[dim[\"column\"]] = df[dim[\"column\"]]\n\n    out_path.parent.mkdir(parents=True, exist_ok=True)\n    output_df.to_csv(out_path, index=False)\n\n    dimension_summaries = compute_dimension_summaries(df, weights, dimensions)\n\n    manifest = {\n        \"analysis\": \"Scenario 1 proxy weight calibration\",\n        \"command\": shlex.join([\"python\", Path(__file__).as_posix(), *sys.argv[1:]]),\n        \"dataset\": str(csv_path),\n        \"config\": str(config_path),\n        \"targets\": str(targets_path),\n        \"seed\": seed,\n        \"timestamp_utc\": dt.datetime.now(dt.timezone.utc).isoformat(),\n        \"max_iter\": args.max_iter,\n        \"tolerance\": args.tol,\n        \"diagnostics\": diagnostics,\n        \"dimension_targets\": targets_cfg.get(\"dimensions\", []),\n        \"achieved_shares\": dimension_summaries,\n        \"privacy_guardrail\": f\"All calibration categories >= {PRIVACY_MIN_COUNT} respondents.\",\n        \"outputs\": {\n            \"pseudo_weights_csv\": str(out_path),\n        },\n    }\n\n    manifest_path.parent.mkdir(parents=True, exist_ok=True)\n    with manifest_path.open(\"w\", encoding=\"utf-8\") as handle:\n        json.dump(manifest, handle, indent=2)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1:])\n",
      "mode": "text"
    },
    {
      "path": "artifacts/pseudo_weight_manifest.json",
      "content": "{\n  \"analysis\": \"Scenario 1 proxy weight calibration\",\n  \"command\": \"python /Users/wessel/ai_scientist/experiment_2_aella_mimimal/scripts/generate_pseudo_weights.py --csv childhoodbalancedpublic_original.csv --config config/agent_config.yaml --targets docs/calibration_targets.yaml --out tables/pseudo_weights.csv --manifest artifacts/pseudo_weight_manifest.json\",\n  \"dataset\": \"childhoodbalancedpublic_original.csv\",\n  \"config\": \"config/agent_config.yaml\",\n  \"targets\": \"docs/calibration_targets.yaml\",\n  \"seed\": 20251016,\n  \"timestamp_utc\": \"2025-11-04T20:23:19.411544+00:00\",\n  \"max_iter\": 50,\n  \"tolerance\": 1e-06,\n  \"diagnostics\": {\n    \"iterations\": 5,\n    \"converged\": true,\n    \"tolerance\": 1e-06,\n    \"max_abs_error\": 4.13842029534095e-07,\n    \"error_history\": [\n      0.08654082069613889,\n      0.004065323933303,\n      0.00018985616666772342,\n      8.864056127655395e-06,\n      4.13842029534095e-07\n    ]\n  },\n  \"dimension_targets\": [\n    {\n      \"name\": \"biomale\",\n      \"dataset_column\": \"biomale\",\n      \"type\": \"categorical\",\n      \"categories\": [\n        {\n          \"value\": 1.0,\n          \"label\": \"biologically_male\",\n          \"target_share\": 0.491,\n          \"documentation\": \"ACS 2023 Table S0101 (Male: 49.1%)\"\n        },\n        {\n          \"value\": 0.0,\n          \"label\": \"not_biologically_male\",\n          \"target_share\": 0.509,\n          \"documentation\": \"ACS 2023 Table S0101 (Female/other: 50.9%)\"\n        }\n      ]\n    },\n    {\n      \"name\": \"age_group\",\n      \"dataset_column\": \"selfage\",\n      \"type\": \"numeric_binned\",\n      \"bins\": [\n        {\n          \"label\": \"18-29\",\n          \"min_inclusive\": 18,\n          \"max_inclusive\": 29,\n          \"target_share\": 0.212,\n          \"documentation\": \"ACS 2023 Table S0101: 18 to 29 years (21.2%)\"\n        },\n        {\n          \"label\": \"30-44\",\n          \"min_inclusive\": 30,\n          \"max_inclusive\": 44,\n          \"target_share\": 0.258,\n          \"documentation\": \"ACS 2023 Table S0101: 30 to 44 years (25.8%)\"\n        },\n        {\n          \"label\": \"45-64\",\n          \"min_inclusive\": 45,\n          \"max_inclusive\": 64,\n          \"target_share\": 0.321,\n          \"documentation\": \"ACS 2023 Table S0101: 45 to 64 years (32.1%)\"\n        },\n        {\n          \"label\": \"65+\",\n          \"min_inclusive\": 65,\n          \"max_inclusive\": 120,\n          \"target_share\": 0.209,\n          \"documentation\": \"ACS 2023 Table S0101: 65 years and over (20.9%)\"\n        }\n      ]\n    }\n  ],\n  \"achieved_shares\": {\n    \"biomale\": {\n      \"1.0\": 0.491,\n      \"0.0\": 0.509\n    },\n    \"age_group\": {\n      \"18-29\": 0.212,\n      \"30-44\": 0.258,\n      \"45-64\": 0.321,\n      \"65+\": 0.209\n    }\n  },\n  \"privacy_guardrail\": \"All calibration categories >= 10 respondents.\",\n  \"outputs\": {\n    \"pseudo_weights_csv\": \"tables/pseudo_weights.csv\"\n  }\n}",
      "mode": "text"
    },
    {
      "path": "artifacts/state.json",
      "content": "{\n  \"artifacts\": {\n    \"design_metadata_brief\": \"reports/design_metadata_brief.md\",\n    \"h1_difference\": \"tables/h1_religion_by_biomale_diff.csv\",\n    \"h1_group_stats\": \"tables/h1_religion_by_biomale.csv\",\n    \"h1_manifest\": \"artifacts/h1_religion_by_biomale_manifest.json\",\n    \"h2_differences\": \"tables/h2_happiness_by_religion_strictness_diff.csv\",\n    \"h2_group_stats\": \"tables/h2_happiness_by_religion_strictness.csv\",\n    \"h2_manifest\": \"artifacts/h2_religion_strictness_vs_happiness_manifest.json\",\n    \"calibration_targets\": \"docs/calibration_targets.yaml\",\n    \"pseudo_weight_manifest\": \"artifacts/pseudo_weight_manifest.json\",\n    \"findings_summary\": \"reports/findings_summary.md\",\n    \"sensitivity_plan\": \"analysis/sensitivity_plan.md\",\n    \"manuscript_markdown\": \"reports/manuscript.md\",\n    \"manuscript_tex\": \"manuscript.tex\",\n    \"hypotheses_registry\": \"analysis/hypotheses.csv\",\n    \"pre_analysis_plan\": \"analysis/pre_analysis_plan.md\",\n    \"research_notebook\": \"notebooks/research_notebook.md\"\n  },\n  \"backlog\": [\n    {\n      \"description\": \"Validate survey weights and replicate design metadata\",\n      \"id\": \"T-001\",\n      \"priority\": 1,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Generate exploratory weighted summaries for key outcomes\",\n      \"id\": \"T-002\",\n      \"priority\": 2,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Monitor for sponsor-provided survey design metadata updates\",\n      \"id\": \"T-003\",\n      \"priority\": 3,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Draft sponsor-ready brief summarizing design metadata gaps and needed files\",\n      \"id\": \"T-004\",\n      \"priority\": 3,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Follow up with sponsor on requested design deliverables\",\n      \"id\": \"T-005\",\n      \"priority\": 1,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Update design files upon receipt of sponsor metadata\",\n      \"id\": \"T-006\",\n      \"priority\": 3,\n      \"status\": \"blocked\"\n    },\n    {\n      \"description\": \"Estimate H1 active religion practice rates by biological sex\",\n      \"id\": \"T-007\",\n      \"priority\": 2,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Develop H2 analysis script for religion strictness vs adult happiness change\",\n      \"id\": \"T-008\",\n      \"priority\": 1,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Update manuscript and reports with design context and H1 findings\",\n      \"id\": \"T-009\",\n      \"priority\": 2,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Summarize H2 findings and integrate into manuscript drafts\",\n      \"id\": \"T-010\",\n      \"priority\": 2,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Plan sensitivity strategy for missing survey weights and replicate designs\",\n      \"id\": \"T-011\",\n      \"priority\": 1,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Prototype exploratory analysis for H-003 (net worth vs work satisfaction)\",\n      \"id\": \"T-012\",\n      \"priority\": 2,\n      \"status\": \"todo\"\n    },\n    {\n      \"description\": \"Curate external calibration targets and develop deterministic pseudo-weight script\",\n      \"id\": \"T-013\",\n      \"priority\": 1,\n      \"status\": \"done\"\n    },\n    {\n      \"description\": \"Generate design-effect multiplier grid and reporting template\",\n      \"id\": \"T-014\",\n      \"priority\": 2,\n      \"status\": \"todo\"\n    },\n    {\n      \"description\": \"Prototype pseudo-PSU clustering and replicate weight generation\",\n      \"id\": \"T-015\",\n      \"priority\": 2,\n      \"status\": \"todo\"\n    }\n  ],\n  \"bootstrap_complete\": true,\n  \"loop_counter\": 10,\n  \"next_actions\": [\n    {\n      \"desc\": \"Prototype exploratory analysis for H-003 (net worth vs work satisfaction)\",\n      \"estimate_min\": \"45m\",\n      \"id\": \"T-012\",\n      \"priority\": 2\n    },\n    {\n      \"desc\": \"Generate design-effect multiplier grid and reporting template\",\n      \"estimate_min\": \"40m\",\n      \"id\": \"T-014\",\n      \"priority\": 2\n    }\n  ],\n  \"regeneration_commands\": {\n    \"bootstrap\": \"python scripts/bootstrap_artifacts.py\",\n    \"design_brief\": \"python scripts/generate_design_brief.py --out reports/design_metadata_brief.md\",\n    \"design_monitoring\": \"python scripts/design_scan.py --csv childhoodbalancedpublic_original.csv\",\n    \"design_validation\": \"python scripts/design_scan.py --csv childhoodbalancedpublic_original.csv\",\n    \"exploratory_summaries\": \"python scripts/exploratory_summaries.py --csv childhoodbalancedpublic_original.csv --config config/agent_config.yaml --out tables/summary_key_outcomes.csv\",\n    \"h1_religion_analysis\": \"python scripts/analyze_h1_religion_by_biomale.py --csv childhoodbalancedpublic_original.csv --config config/agent_config.yaml --design docs/survey_design.yaml --out tables/h1_religion_by_biomale.csv --diff-out tables/h1_religion_by_biomale_diff.csv --manifest artifacts/h1_religion_by_biomale_manifest.json\",\n    \"h2_religion_analysis\": \"python scripts/analyze_h2_religion_strictness_vs_happiness.py --csv childhoodbalancedpublic_original.csv --config config/agent_config.yaml --design docs/survey_design.yaml --out tables/h2_happiness_by_religion_strictness.csv --diff-out tables/h2_happiness_by_religion_strictness_diff.csv --manifest artifacts/h2_religion_strictness_vs_happiness_manifest.json\",\n    \"sensitivity_plan\": \"python scripts/generate_sensitivity_plan.py --out analysis/sensitivity_plan.md --timestamp 2025-11-04T08:24:44Z\",\n    \"sponsor_follow_up\": \"python scripts/generate_sponsor_follow_up.py --brief reports/design_metadata_brief.md --out reports/sponsor_follow_up.md\",\n    \"pseudo_weight_calibration\": \"python scripts/generate_pseudo_weights.py --csv childhoodbalancedpublic_original.csv --config config/agent_config.yaml --targets docs/calibration_targets.yaml --out tables/pseudo_weights.csv --manifest artifacts/pseudo_weight_manifest.json\"\n  },\n  \"seed\": 20251016,\n  \"total_loops\": 30\n}\n",
      "mode": "text"
    }